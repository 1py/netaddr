=IP Address Tutorial=

Copyright (c) 2008-2009, David P. D. Moss. All rights reserved.

This unit test serves as both testing of the netaddr API and an executable tutorial courtesy of the doctest and unittest modules in the Python standard library.

Let's start with the standard module import.

{{{

>>> from netaddr import *

}}}

You can safely import everything from the netaddr namespace as care has been taken to only export the necessary classes, functions and constants. You can always hand pick them if you are unsure.

==Basic IP Operations==

This IP object represents a single address.

{{{

>>> ip = IP('192.0.2.1')

}}}

Standard repr() access returns a Python statement that can reconstruct the IP address object from scratch if executed in the Python interpreter.

{{{

>>> ip
IP('192.0.2.1')

}}}

Access in the string context returns the IP object as a string value.

{{{

>>> str(ip)
'192.0.2.1'

>>> '%s' % ip
'192.0.2.1'

}}}

Here are a few other common properties.

{{{

>>> str(ip), ip.prefixlen, ip.version
('192.0.2.1', 32, 4)

}}}

==IP Address Numerical Representations==

You can view an individual IP address in various other formats.

{{{

>>> int(ip)
3221225985L

>>> hex(ip)
'0xc0000201'

>>> ip.bits()
'11000000.00000000.00000010.00000001'

>>> ip.bin()
'0b11000000000000000000001000000001'

}}}

==Representing IP Subnets==

You might be wondering at this point what an IP object actually represents.

Is it :-

a) single IP address
b) an IP subnet
c) a combination of both

The answer depends on what you pass to the constructor. The IP object is flexible enough to be all three. Technically, it is option c). While this may seem a bit odd at first it isn't a problem in practice. You access the information you require from using the object in different ways.

Here is some examples to illustrate this :-

This IP object represents a single address.

{{{

>>> ip = IP('192.0.2.1')
>>> ip.ip, ip.network, ip.broadcast, ip.netmask, ip.hostmask, ip.size
(IP('192.0.2.1'), IP('192.0.2.1'), IP('192.0.2.1'), IP('255.255.255.255'), IP('0.0.0.0'), 1)

}}}

In this case, the network and broadcast address at the same as the actual IP address, so you probably don't care about them.

This IP object represents a subnet.

{{{

>>> ip = IP('192.0.2.0/24')
>>> ip.ip, ip.network, ip.broadcast, ip.netmask, ip.hostmask, ip.size
(IP('192.0.2.0'), IP('192.0.2.0'), IP('192.0.2.255'), IP('255.255.255.0'), IP('0.0.0.255'), 256)

}}}

Note here that the value of the IP address and its network address match. This is a *true* CIDR address (i.e. it doesn't have any non-zero bits to the right of the subnet mask.

An finally, this IP object represents a single address that belong to a given subnet.

{{{

>>> ip = IP('192.0.3.112/22')
>>> ip.ip, ip.network, ip.broadcast, ip.netmask, ip.hostmask, ip.size
(IP('192.0.3.112'), IP('192.0.0.0'), IP('192.0.3.255'), IP('255.255.252.0'), IP('0.0.3.255'), 1024)

}}}

Internally, each IP object only stores 3 integers, the IP address value, the version of IP protocol the address represents and its CIDR prefix. All the other values are calculated on-the-fly as they are accessed.

It is possible to adjust the IP address value and the CIDR prefix after object instantiation.

{{{

>>> ip = IP(0)
>>> ip
IP('0.0.0.0')
>>> ip.value = '192.0.2.1'
>>> ip
IP('192.0.2.1')
>>> ip.prefixlen
32
>>> ip.prefixlen = 23
>>> ip
IP('192.0.2.1/23')

}}}

There is also a property that lets you access the actual *true* CIDR address (after applying the CIDR prefix to the IP address of the IP object).

{{{

>>> ip.cidr
IP('192.0.2.0/23')

}}}

This is handy for specifying some networking configurations correctly.

If you want to access information about each of the various IP addresses that form the IP subnet, this is available by performing pass through calls to sub methods of each object.

For example if you want to see a binary digit representation of each address you can do the following.

{{{

>>> ip.ip.bits()
'11000000.00000000.00000010.00000001'

>>> ip.network.bits()
'11000000.00000000.00000010.00000000'

>>> ip.netmask.bits()
'11111111.11111111.11111110.00000000'

>>> ip.broadcast.bits()
'11000000.00000000.00000011.11111111'

}}}

==IPv6 support==

IP objects provide full support for IPv6 addresses as well. To prove this, let's try a few examples.

{{{

>>> ip = IP(0, 6)
>>> ip
IP('::')

>>> ip = IP('fe80::dead:beef/64')

>>> str(ip), ip.prefixlen, ip.version
('fe80::dead:beef/64', 64, 6)

>>> int(ip)
338288524927261089654018896845083623151L

>>> hex(ip)
'0xfe8000000000000000000000deadbeef'

Bit-style output isn't as quite as friendly as hexadecimal for such a long numbers, but here the proof that it at least works!

>>> ip.bits()
'1111111010000000:0000000000000000:0000000000000000:0000000000000000:0000000000000000:0000000000000000:1101111010101101:1011111011101111'

Here are some networking details for an IPv6 subnet.

>>> ip.network, ip.broadcast, ip.netmask, ip.hostmask
(IP('fe80::'), IP('fe80::ffff:ffff:ffff:ffff'), IP('ffff:ffff:ffff:ffff::'), IP('::ffff:ffff:ffff:ffff'))

}}}

==IPv4 / IPv6 Interoperability==

It is likely that with IPv6 becoming more prevalent, you'll want to be able to interoperate between IPv4 and IPv6 address seemlessly.

Here are a couple of handy methods provided by the IP object to help you to this end.

{{{

>>> ip = IP('192.0.2.1/23')

>>> ip.ipv4()
IP('192.0.2.1/23')

>>> ip.ipv6()
IP('::ffff:192.0.2.1/119')

>>> ip.ipv6(ipv4_compatible=True)
IP('::192.0.2.1/119')

}}}

Note that the IP object returns IPv4 "mapped" addresses by default in preference to IPv4 "compatible" ones. This has been chosen purposefully as the latter form has been deprecated (see RFC 4291 for details).

==List Operations On IP Objects==

If you treat an IP object as if it were a standard Python list object it will behave as if you are accessing a list of individual IP objects. This of course is illusory and they are not created until you access them.

{{{

>>> ip = IP('192.0.2.16/29')

}}}

Accessing an IP object using the list() context invokes the default generator which returns a list of all IP objects in the range specified by the IP object's subnet.

{{{

>>> ip_list = list(ip)
>>> len(ip_list)
8
>>> ip_list
[IP('192.0.2.16'), IP('192.0.2.17'), ..., IP('192.0.2.22'), IP('192.0.2.23')]

}}}

The length of that list is 8 individual IP addresses.

{{{

>>> len(ip)
8

}}}

You can use standard index access to IP addresses in the subnet.

{{{

>>> ip[0]
IP('192.0.2.16')

>>> ip[1]
IP('192.0.2.17')

>>> ip[-1]
IP('192.0.2.23')

}}}

You can even uses extended slices on IP addresses in the subnet.

{{{

>>> ip[0:4]
<generator object ...>

}}}

The slice is actually a generator function. This is to save time and system resources. Some slices can obviously end up being extremely large for some subnets! 

Here is how you'd access all elements in a slice.

{{{

>>> list(ip[0:4])
[IP('192.0.2.16'), IP('192.0.2.17'), IP('192.0.2.18'), IP('192.0.2.19')]

}}}

Extended slicing is also supported.

{{{

>>> list(ip[0::2])
[IP('192.0.2.16'), IP('192.0.2.18'), IP('192.0.2.20'), IP('192.0.2.22')]

}}}

List reversal.

{{{

>>> list(ip[-1::-1])
[IP('192.0.2.23'), IP('192.0.2.22'), ..., IP('192.0.2.17'), IP('192.0.2.16')]

}}}

Use of generators ensures working with large IP subnets is efficient.

{{{

>>> for ip in IP('192.0.2.0/23'):
...    print '%s' % ip
...
192.0.2.0
192.0.2.1
192.0.2.2
192.0.2.3
...
192.0.3.252
192.0.3.253
192.0.3.254
192.0.3.255

}}}

In IPv4 networks you only usually assign the addresses between the network and broadcast addresses to actual host interfaces on systems.

Here is the iterator provided for accessing these IP addresses :-

{{{

>>> for ip in IP('192.0.2.0/23').iter_hosts():
...     print '%s' % ip
...
192.0.2.1
192.0.2.2
192.0.2.3
192.0.2.4
...
192.0.3.251
192.0.3.252
192.0.3.253
192.0.3.254

}}}

==Sorting Collection Of IP Objects==

It is fairly common and useful to be able to sort IP addresses correctly (in numerical order).

Here is how sorting works with individual addresses.

{{{

>>> import random
>>> ip_list = list(IP('192.0.2.128/28'))
>>> random.shuffle(ip_list)
>>> sorted(ip_list)
[IP('192.0.2.128'), IP('192.0.2.129'), IP('192.0.2.130'), IP('192.0.2.131'), IP('192.0.2.132'), IP('192.0.2.133'), IP('192.0.2.134'), IP('192.0.2.135'), IP('192.0.2.136'), IP('192.0.2.137'), IP('192.0.2.138'), IP('192.0.2.139'), IP('192.0.2.140'), IP('192.0.2.141'), IP('192.0.2.142'), IP('192.0.2.143')]

}}}

You can just as easily sort IP subnets at the same time, including combinations of IPv4 and IPv6 addresses as well.

{{{

>>> ip_list = [IP('192.0.2.130'), IP('10.0.0.1'), IP('192.0.2.128/28'), IP('192.0.3.0/24'), IP('192.0.2.0/24'), IP('fe80::/64'), IP('::'), IP('172.24/12')]
>>> random.shuffle(ip_list)
>>> ip_list.sort()
>>> ip_list
[IP('10.0.0.1'), IP('172.0.0.24/12'), IP('192.0.2.0/24'), IP('192.0.2.128/28'), IP('192.0.2.130'), IP('192.0.3.0/24'), IP('::'), IP('fe80::/64')]

}}}

Notice how IPv4 is ordered before IPv6 and overlapping subnets sort in order from largest subnet to smallest.

==Merging IP Addresses And Subnets==

Another useful operation is the ability to summarize groups of IP subnets and addresses, merging them together where possible to create the smallest possible list of CIDR subnets.

Here is how to do this using the cidr_merge() function.

First we create a list of IP objects that is a good mix of individual addresses and subnets, along with some string based IP address values for good measure. To make things more challenging some IPv6 addresses have been included as well.

{{{

>>> ip_list = [ip for ip in IP('fe80::/120')]
>>> ip_list.append(IP('192.0.2.0/24'))
>>> ip_list.extend([str(ip) for ip in IP('192.0.3.0/24')])
>>> ip_list.append(IP('192.0.4.0/25'))
>>> ip_list.append(IP('192.0.4.128/25'))
>>> len(ip_list)
515
>>> cidr_merge(ip_list)
[IP('192.0.2.0/23'), IP('192.0.4.0/24'), IP('fe80::/120')]

}}}

==Dealing With Arbitrary Lists Of IP Objects==

While CIDR subnets are a useful construct, sometimes it is necessarily (particularly with IPv4 which predates the CIDR specification) to be able to generate lists of IP addresses that have an arbitrary start and end address that do not fall on bit mask boundaries.

The iter_iprange() function allow you to do just this.

{{{

>>> ip_list = list(iter_iprange('192.0.2.1', '192.0.2.14'))
>>> len(ip_list)
13
>>> ip_list
[IP('192.0.2.1'), IP('192.0.2.2'), ..., IP('192.0.2.12'), IP('192.0.2.13')]

}}}

It is equally nice to know what the actual list of CIDR subnets is that would correctly cover this non-aligned range of addresses.

Here is cidr_merge() coming to the rescue.

{{{

>>> cidr_merge(ip_list)
[IP('192.0.2.1'), IP('192.0.2.2/31'), IP('192.0.2.4/30'), IP('192.0.2.8/30'), IP('192.0.2.12/31')]

}}}

==IP Subnetting And Supernetting==

It is quite common to have a large CIDR subnet that you may want to split up into multiple smaller component blocks to better manage your networks.

{{{

>>> ip = IP('172.24.0.0/16')
>>> ip.subnet(23)
<generator object ...>

}}}

Again this method produces and iterator because of the possibility for a large number of return values.

{{{

>>> subnets = list(ip.subnet(23))
>>> len(subnets)
128
>>> subnets
[IP('172.24.0.0/23'), IP('172.24.2.0/23'), IP('172.24.4.0/23'), ..., IP('172.24.250.0/23'), IP('172.24.252.0/23'), IP('172.24.254.0/23')]

}}}

It is also possible to retrieve the list of supernets that a given IP address or subnet belongs to (with an optional limit).
 
{{{

>>> ip = IP('192.0.2.114')
>>> ip.supernet(22)
[IP('192.0.0.0/22'), IP('192.0.2.0/23'), IP('192.0.2.0/24'), IP('192.0.2.0/25'), IP('192.0.2.64/26'), IP('192.0.2.96/27'), IP('192.0.2.112/28'), IP('192.0.2.112/29'), IP('192.0.2.112/30'), IP('192.0.2.114/31')]

}}}

This method returns a list because the potential list of values is of a predictable size (no more than 31 CIDRs for an IPv4 address and 127 for IPv6).

==Dealing With Less Common IP Network Specifications==

Until the advent of the CIDR specification it was common to infer the netmask of an IPv4 address based on its first octet using an set of classful rules.

It is common to come across these in various RFCs and they are well supported by a number of software libraries. Rather than leave out this important (mainly historical) set of rules they are catered for using the cidr_abbrev_to_verbose() function.

Here is an example of these rules for the whole of the IPv4 address space.

{{{

>>> cidrs = [cidr_abbrev_to_verbose(octet) for octet in range(0, 256)]
>>> len(cidrs)
256
>>> cidrs
['0.0.0.0/8', ..., '127.0.0.0/8', '128.0.0.0/16', ..., '191.0.0.0/16', '192.0.0.0/24', ..., '223.0.0.0/24', '224.0.0.0/4', '225.0.0.0/8', ..., '239.0.0.0/8', '240.0.0.0/32', ..., '255.0.0.0/32']

}}}

==IP Address Categories==

IP addresses fall several broad categories and not all are suitable for assignment as system interface addresses.

Unicast

>>> IP('192.0.2.1').is_unicast()
True

>>> IP('fe80::1').is_unicast()
True

Multicast

>>> IP('239.192.0.1').is_multicast()
True

>>> IP('ff00::1').is_multicast()
True

Private

>>> IP('172.24.0.1').is_private()
True

>>> IP('10.0.0.1').is_private()
True

>>> IP('192.168.0.1').is_private()
True

Reserved

>>> IP('253.0.0.1').is_reserved()
True

Public (Internet) addresses.

Note that not all of these may be allocated by the various regional Internet registrars.

>>> ip = IP('62.125.24.5')
>>> ip.is_unicast() and not ip.is_private()
True

There are also other types of addresses that have specific functions e.g. masking

Netmasks

>>> IP('255.255.254.0').is_netmask()
True

Hostmasks

>>> IP('0.0.1.255').is_hostmask()
True

Loopback addresses

IPv4

>>> IP('127.0.0.1').is_loopback()
True

IPv6

>>> IP('::1').is_loopback()
True

==IP address comparisons==

IP objects can be compared with each other. As an IP object can represent both an individual IP address and an implicit network, it pays to get both sides of your comparison into the same terms before you compare them to avoid any odd results.

Here are some comparisons of individual IP address to get the ball rolling.

>>> IP('192.0.2.1') == IP('192.0.2.1')
True

>>> IP('192.0.2.1') < IP('192.0.2.2')
True

>>> IP('192.0.2.2') > IP('192.0.2.1')
True

>>> IP('192.0.2.1') != IP('192.0.2.1')
False

>>> IP('192.0.2.1') >= IP('192.0.2.1')
True

>>> IP('192.0.2.2') >= IP('192.0.2.1')
True

>>> IP('192.0.2.1') <= IP('192.0.2.1')
True

>>> IP('192.0.2.1') <= IP('192.0.2.2')
True

Now lets try something a little more interesting.

>>> IP('192.0.2.0/24') == IP('192.0.2.112/24')
True

Hmmmmmmmm... looks a bit odd doesn't it? That's because by default, IP objects compare their subnets (or lower and upper boundaries) rather than their individual IP address values.

The solution to this situation is very simple. Knowing this default behaviour, just be explicit about exactly which portion of each IP object you'd like to compare using pass-through properties.

>>> IP('192.0.2.0/24').ip == IP('192.0.2.112/24').ip
False

>>> IP('192.0.2.0/24').ip < IP('192.0.2.112/24').ip
True

That's more like it. You can also be explicit about comparing networks in this way if you so wish (although it is not strictly necessary).

>>> IP('192.0.2.0/24').cidr == IP('192.0.2.112/24').cidr
True

Armed with this information here are some examples of network comparisons.

>>> IP('192.0.2.0/24') == IP('192.0.3.0/24')
False

>>> IP('192.0.2.0/24') < IP('192.0.3.0/24')
True

>>> IP('192.0.2.0/24') < IP('192.0.3.0/24')
True

==Interaction with DNS==

It is a common administrative task to Generating reverse IP lookups for DNS. This is particularly arduous for IPv6 addresses.

Here is how you do this using the IP object's reverse_dns() method.

IPv4

{{{

>>> IP('172.24.0.13').reverse_dns()
'13.0.24.172.in-addr.arpa.'

}}}

IPv6

{{{

>>> IP('fe80::feeb:daed').reverse_dns()
'd.e.a.d.b.e.e.f.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.8.e.f.ip6.arpa.'

}}}

Note that ip6.int is not used as this has been deprecated (see RFC 3152 for details).
